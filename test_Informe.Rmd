---
title: "Identificación de genes que intervienen en la patogénesis del síndrome de Turner"
author: "Félix Francisco Enríquez Romero" 
date: "15/4/2021"
output:
  html_document:
    toc: yes
    number_sections: yes
    theme: cerulean
---
Repositorio en github: <https://github.com/ffer200395/Microarrays.git>
```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(echo = T, eval = FALSE)
```

# Abstract

El síndrome de Turner es un trastorno genético que afecta a mujeres y se caracteriza por la pérdida de uno de sus cromosomas sexuales X. Las pacientes con dicho síndrome presenta una amplia variedad de síntomas entre los que destacan baja estatura, infertilidad y deformidades oseas.

Dependiendo del origen parental del cromosoma X se puede hacer distinción entre las pacientes Xm y Xp en función de si el cromosoma X heredado proviene la madre o del padre. Fenotípicamente las pacientes con síndrome de Turner Xm y Xp difieren en la severidad de los síntomas.

Los mecanismos que dan lugar al síndrome de Turner son complejos y aún no están claros.

# Objetivos

* Identificar genes diferencialmente expresados entre:
  + Mujeres que presentan el síndrome de Turner (X_) y las que no (XX).
  + Mujeres con ST cuyo cromosoma X es heredado de la madre (Xm) y las que heredaron del padre (Xp).
  
* Mostrar los pasos realizados en el análisis y proveer al investigador/a de resultados que le permita realizar una interpretación biológica.

# Materiales y métodos

## Naturaleza de los datos, tipo de experimento, diseño experimental y tipo de microarrays utilizados 

Partimos de unos datos en formato .CEL que son la expresión génica en microarrays de tipo "Affymetrix Human Genome U133 Plus 2.0 Array" de mujeres con y sin síndrome de Turner. El dataset original puede obtenerse en Gene Expresion Omnibus ([GEO](https://www.ncbi.nlm.nih.gov/geo/query/acc.cgi?acc=GSE46687)) con el identificador "GSE46687" descargando los archivos .CEL. 

Tras aplicar una función que selecciona muestras del dataset original obtenemos un dataset balanceado de 18 muestras, 6 por cariotipo (45Xm, 45Xp, 46XX).

Estamos ante un estudio observacional de un factor con 3 niveles que corresponden con el tipo de cariotipo. Por un lado se realiza una comparación X_ vs XX con el fin de estudiar los cambios de expresión a nivel genómico entre mujeres con ST y las que no. Otra comparación que se realiza es Xm vs Xp con el fin de estudiar el impacto fenotipico en el ST dependiendo si el cromosoma X proviene por vía materna o paterna.

## Métodos utilizados en el análisis (Pipeline)

El proceso de análisis de microarrays sigue un flujo de trabajo ordenado que va desde la correcta lectura y control de calidad de los datos a un análisis de la significación biológica de los resultados.

Tras descargar los archivos .CEL se selecciona una muestra aleatoria que contenga individuos pertenecientes a los 3 grupos del experimento. Los archivos .CEL de los individuos que son seleccionados se cargan en el entorno de trabajo usando a función read.affybatch del paquete affy. Estos datos primeros pasan por un control de calidad en crudo que nos permitirá detectar posibles anomalías/errores en las muestras seleccionadas.

Si se observan que los datos presentan suficiente calidad pasamos a normalizarlos. Se normalizan con el fin de reducir la variabilidad entre las muestras que no sea debida a factores biológicos, hacer las muestras comparables entre sí y reducir el ruido de fondo. Una vez son normalizados se les aplica un filtraje no específico que permite eliminar los genes que varían poco entre los grupos o de los cuales no se dispone de anotacion.

Realizamos la anotación de los genes como paso previo a la obtención de las listas de genes diferencialmente expresados (GDEs). Para obtener estas listas se ha optado por el uso de modelos lineales implementado en el paquete [limma](https://bioconductor.org/packages/release/bioc/html/limma.html), por lo que hemos definido una matriz de diseño que modela el experimento y una matriz de contraste que nos permitirá hacer comparaciones entre los parámetros del modelo estimado. 

Haciendo uso de las funciones constrasts.fit y eBayes del paquete limma se calcula el log fold-change y los p-valores correspondientes para cada gen en cada uno de los constrastes planteados. Con la función topTable se obtiene un data.frame con información sobre la expresión diferencial de los genes.

Por último, usamos los identificadores de los genes que muestran una expresión diferencial estadísticamente significativa y la función hyperGTest del paquete GOstats para obtener resultados de búsqueda relacionados con la función biológica de los conjuntos de genes encontrados o las rutas metabólicas en las que están implicados.

## Descripción cualitativa de cada paso

### Carga de los datos

- Objetivo: Crear un objeto del tipo AffyBatch con el que poder comenzar el análisis de los datos.

- Input: Para cear un objeto AffyBatch partimos de un conjunto de **archivos .CEL** y un archivo **targetsAll.csv** que usaremos para la selección de muestras y dar a estas un nombre más intuitivo.

- Output: Objeto AffyBatch llamado **rawData** sobre el que empezaremos a trabajar.

### Control de calidad de los datos en crudo

- Objetivo: Determinar si los datos de las muestra datos es de suficiente para su posterior normalización o si es necesario eliminar alguna para mejorar la calidad del experimento.

- Input: Objeto AffyBatch **rawData** generado anteriormente.

- Output: Boxplot **boxplot_qcRaw.png**, histograma **hist_qcRaw.png** y salida de la función qc() **qc_statsRaw.png**.

### Normalización

- Objetivo: Corregir diferencias sistemáticas entre las muestras y transformar los datos de forma que estos sean comparables entre sí.

- Input: Objeto AffyBatch **rawData**.

- Output: Objeto ExpressionSet **processedData** obtenido al aplicar la función rma() del paquete affy (almacenado en **normalized.Data.csv**).

### Filtraje no específico

- Objetivo: Eliminar ruido de fondo mediante la eliminación de genes que no muestran una variación significativa en su señal.

- Input: Objeto ExpressionSet **processedData** obtenido en el paso previo.

- Output: Objeto ExpresionSet **pro_filt_data** obtenido tras aplicar la función nsFilter() del paquete genefilter (almacenado en **normalized.Filtered.Data.csv**).

### Selección y anotación de genes diferencialmente expresados

- Objetivo: Determinar que genes son los que se están expresando de manera diferencial de estadísiticamente significativa.

- Input: Objeto ExpresionSet **pro_filt_data** con los datos normalizados y filtrados.

- Output: Dos data.frame **topTab_XmvsXp** y **topTab_XXvsX_** que contienen las listas de genes anotados con mayor diferencia en su expresión correspondientes a los dos contrastes que hemos realizado. Además los volcano plots han sido almacenados en los archivos **volcPlot_XXX_.png** y **volcPlot_XmXp.png**.

### Análisis de la significación biológica (“Gene Enrichment Analysis”)

- Objetivo: Establecer si un proceso biológico o ruta metabólica aparece con mayor o menor frecuencia en la lista de genes seleccionados respecto al conjunto total de genes desde donde se ha obtenido.

- Input: Las topTable obtenidas en el apartado anterior, **topTab_XmvsXp** y **topTab_XXvsX_**.

- Output: Archivos .html del anális de enriquecimiento (prefijos GO y KEGG).


# Resultados del análisis

Tras la carga de los datos y la selección de las muestras realizamos un análisis exploratorio y un control de calidad de los datos en crudo. 


Que se obtiene como resultado del análisis *Comentar código de mientras e ir hacendo el knit a la vez

-Tabla con grupos y muestras.
-Plots del control de calidad y comentarlos.
-Mostrar genes eliminados en el filtro.

-Mostrar matriz de diseño/contraste

-Mostrar las top table

-Mostrar los vulcano plots

-Mostrar .... de la significación biológica .... y entrar en detalles

# Apéndice

```{r imports}
# Instalación de paquetes requeridos
if (!(require(stringr))) install.packages("stringr")
if (!(require(tm))) install.packages("tm")
if (!(require(knitr))) install.packages("knitr")
if (!(require(BiocManager))) install.packages("BiocManager")

if (!require(affy))BiocManager::install("affy")
if (!require(affycoretools))BiocManager::install("affycoretools")
if (!require(genefilter))BiocManager::install("genefilter")
if (!require(GOstats))BiocManager::install("GOstats")
if (!(require(hgu133plus2.db)))BiocManager::install("hgu133plus2.db")
if (!require(Biobase))BiocManager::install("Biobase")
if (!require(simpleaffy))BiocManager::install("simpleaffy")
if (!require(affyPLM))BiocManager::install("affyPLM")
```

```{r load}
library(Biobase)
library(affy)
library(tm)

# Directorios
workingDir <- getwd()
rawDataDir <- file.path(workingDir, "raw_data")
resultsDir <- file.path(workingDir, "results")

# Función para elegir muestras aleatoriamente
selectSamples<- function (myID){
 set.seed(myID)
 selected <- c(sample(1:10, 6),11, sample(12:26, 5), sample(27:36,6))
 selected <- sort(selected)
}

# Seleccionamos las muestras y almacenamos el nombre de los archivos .CEL
mySelected <- selectSamples(49044820)# Número aleatorio
targetsAll <- read.csv(file="targetsAll.csv", row.names = 1, head=TRUE)
myTargets <- targetsAll[mySelected,]
fileNames <- row.names(myTargets)

# Obtenemos el nombre completo de los archivos .CEL
all_files <- list.files("raw_data/", pattern = "*.CEL.gz", full.names = FALSE) # Todos
selectFiles <- c() # Los que se necesitan
for(i in 1:length(all_files)){
  fullName = all_files[i]
  name = unlist(strsplit(fullName,"_"))[1] 
  if(is.element(name,fileNames)){ # Si el nombre está en nuestro listado entonces lo añadimos
    selectFiles <- c(selectFiles,fullName)
  }
}

# Modificamos la columna karyotype para que no contenga números
myTargets$karyotype <- removeNumbers(myTargets$karyotype)

# Por último leemos los archivos .CEL que nos interesa y creamos un objeto de tipo AffyBatch
rawData <- read.affybatch(filenames = file.path(rawDataDir,selectFiles),phenoData=AnnotatedDataFrame(myTargets))

# Para tener unos nombres más intuitivos
myTargets$title -> colnames(exprs(rawData))
```

```{r qcRaw}
library(simpleaffy)
library(affyPLM)

png(file=paste0(resultsDir,'/boxplot_qcRaw.png'))
# Diagrama de cajas para obtener una idea de las distribución de las intensidades de las distintas muestras
boxplot(rawData, cex.axis=0.8, las=2, col=c(rep("red", 6), rep("blue", 6), rep("green", 6)),main="Distribución de los valores de intensidad en crudo")

png(file=paste0(resultsDir,'/hist_qcRaw.png'))
# Histograma para conocer si las distribuciones de los distintos arrays son similares
hist(rawData, main="Distribución de las señales")

# Hacemos Anális de Comonentes Principales (PCA)
PCA_s <- prcomp(t(exprs(rawData)))
png(file=paste0(resultsDir,'/pca_qcRaw.png'))
plot(PCA_s$x[, 1:2],pch=18, col="blue",main="PCA sobre los datos en crudo")
text(PCA_s$x[, 1:2], row.names(PCA_s$x), cex=0.7, pos=4, offset = 0,col="red")

# Control de calidad en crudo
qualityAnalysisRaw <- qc(rawData)
png(file=paste0(resultsDir,'/qc_statsRaw.png'))
plot(qualityAnalysisRaw)
```


